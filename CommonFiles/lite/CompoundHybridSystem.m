classdef CompoundHybridSystem < HybridSystem
%%% COMPOUNDHYBRIDSYSTEM Creates a hybrid system that consists of N
%%% subsystems. The subsystems are provided as instances of
%%% ControlledHybridSystem with inputs generated by feedback functions
%%% stored in kappa_C and kappa_D. The kappa_C feedbacks are used during
%%% flows and the kappa_D feedbacks are used at jumps.
%%%
%%% The state for the compound system consists of 
%%%     [x1; x2; ...; xN; j1; j2; ...; jN] 
%%% where x1 is the state vector for the first subsystem, x2 is the state
%%% vector for the second subsystem, etc., and j1 is the discrete time for
%%% the first subsystem, j2 is the discrete time for the second subsystem,
%%% and so on. (The subsystems jump separately of each other, so we
%%% maintain separate discrete times).
    
    properties(SetAccess = immutable)
        subsystems (:, 1) cell = {}; 
    end
    
    properties(GetAccess = private, SetAccess = immutable) 
        % The following properties are private because they might change in
        % future implementations. 
        
        % Number of subsystems
        subsys_n;
        
        % Indicies within the compound state of each subsystem's state 
        x_indices cell
        % Index within the compound state of subsystem1's discrete time.
        j_index (:, 1) int32 
    end
    
    properties(Access = private)
        % Feedback function for each subsystem during flows. 
        % Each entry must be set to a function handle with a signiture matching 
        %    u = kappa_C(x1, x2, ..., xN, t, j)
        % where N is the number of subsystems.
        kappa_C
        
        % Feedback functions for each subsystem at jumps.
        % Each entry must be set to a function handle with a signiture matching
        %    u = kappa_D(x1, x2, ..., xN, t, j)
        % where N is the number of subsystems.
        kappa_D
    end
    
    methods
        function obj = CompoundHybridSystem(varargin) % Constructor
           obj = obj@HybridSystem();
           subsystems = split_constructor_varagin(varargin);
           obj.subsystems = subsystems;
           subsys_n = length(subsystems);
           obj.subsys_n = subsys_n;
           ndx = 1; % Start index for ith subsystem state variable.
           for i = 1:subsys_n
               ss = subsystems{i} ;
               ss_n = ss.state_dimension;
               obj.x_indices{i} = ndx : (ndx + ss_n - 1);
               ndx = ndx + ss_n;
           end
           for i = 1:subsys_n
              obj.j_index(i) = ndx;
              ndx = ndx + 1;
           end
           obj.state_dimension = ndx-1;
           
           obj.kappa_C = generate_default_feedbacks(subsystems);
           obj.kappa_D = generate_default_feedbacks(subsystems);
        end
    
        function setContinuousFeedback(this, subsys, kappa_C)
            ndx = subsys_arg_to_ndx(this, subsys);
            this.check_feedback(kappa_C)
            this.kappa_C{ndx} = kappa_C;
        end
    
        function setDiscreteFeedback(this, subsys, kappa_D)
            ndx = subsys_arg_to_ndx(this, subsys);
            this.check_feedback(kappa_D)
            this.kappa_D{ndx} = kappa_D;
        end
    
        function setFeedback(this, subsys, kappa)
            ndx = subsys_arg_to_ndx(this, subsys);
            this.check_feedback(kappa)
            this.kappa_C{ndx} = kappa;
            this.kappa_D{ndx} = kappa;
        end
        
        function disp(this)
            disp(class(this) + ":")
            subsys_prefix = "├";
            prop_prefix = "│";
            for i = 1:this.subsys_n
                ss = this.subsystems{i};
                fprintf("%s Subsystem %d: %s\n", subsys_prefix, i, class(ss))
                fprintf("%s \tContinuous feedback: %s\n", prop_prefix, func2str(this.kappa_C{i}))
                fprintf("%s \t  Discrete feedback: %s\n", prop_prefix, func2str(this.kappa_D{i}))
                fprintf("%s \t             Output: y%d=%s\n", prop_prefix, i, func2str(ss.output))
                fprintf("%s \t         Dimensions: ", prop_prefix)
                fprintf("State=%d, Input=%d, Output=%d\n", ...
                    ss.state_dimension, ss.input_dimension, ss.output_dimension)
                if i == this.subsys_n-1
                    subsys_prefix = "└";
                    prop_prefix = " ";
                end
            end
            
            
        end
    
    end
    
    methods(Sealed)
        
        function xdot = flow_map(this, x, t) 
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs);
            % We set xdot to zeros and then fill in the entries
            % corresponding to the state of each subsystem and leave zero
            % the entries corresponding to the j-values.  
            xdot = zeros(this.state_dimension, 1); 
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               
               u = eval_feedback(this.kappa_C{i}, ys, t, js);
               assert_control_length(length(u), ss.input_dimension, i)
               xdot(this.x_indices{i}) = ss.flow_map(xs{i}, u, t, j);
            end
        end 

        function xplus = jump_map(this, x, t)  
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs);
            xplus = NaN(this.state_dimension, 1);
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               u = eval_feedback(this.kappa_D{i}, ys, t, js);
               assert_control_length(length(u), ss.input_dimension, i)
               D = ss.jump_set_indicator(xs{i}, u, t, j);
               if ~isscalar(D)
                   error("CompoundHybridSystem:InvalidFunction", ...
                       "The jump set indicator function for system %d returned an array.", i)
               end
               if D
                   xplus_i = ss.jump_map(xs{i}, u, t, j);
                   jplus_i = j + 1;
               else
                   xplus_i = xs{i};
                   jplus_i = j;
               end
               assert_state_length(length(xplus_i), ss.state_dimension, i)
               xplus(this.x_indices{i}) = xplus_i;
               xplus(this.j_index(i)) = jplus_i;
            end
        end

        function C = flow_set_indicator(this, x, t) 
            % The system can only flow if both subsystems are in their
            % repsective flow sets (priority is honored, if the compound
            % state is in (C union D)).
            C = true; 
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs);
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               u = eval_feedback(this.kappa_C{i}, ys, t, js);
               assert_control_length(length(u), ss.input_dimension, i)
               C = ss.flow_set_indicator(xs{i}, u, t, j);
               if ~isscalar(C)
                   error("CompoundHybridSystem:InvalidFunction", ...
                       "The flow set indicator function for system %d returned an array.", i)
               end
               if ~C
                   % If any of the subsystems are not in their flow set,
                   % then the compound system does not flow.
                   break;
               end
            end
        end

        function D = jump_set_indicator(this, x, t)
            D = false; 
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs);
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               u = eval_feedback(this.kappa_D{i}, ys, t, js);
               assert_control_length(length(u), ss.input_dimension, i)
               D = ss.jump_set_indicator(xs{i}, u, t, j);
               if D
                   % If any of the subsystems are in their jump set,
                   % then the compound system jumps.
                   break;
               end
            end
        end
    end

    methods
        
        function sol = solve(this, xs_0, tspan, jspan, config)
            % SOLVE Compute the solution to the compound system with the
            % initial state of subsystem1 given by x1_0 and the initial
            % state of subsystem2 given by x2_0. See HybridSystem.solve() for
            % explanation of tspan, jspan, and config.
            
            % We concatenate the subsystem states and inital j-value to create 
            % the compound state. (The subsystems can jump at separate times, 
            % so track the jumps for each in the last components of the 
            % compound state).
            if ~iscell(xs_0)
                error("CompoundHybridSystem:InitialStateNotCell", ...
                    "Initial states xs_0 was a %s instead of a cell array.", ...
                    class(xs_0))
            end
            
            if length(xs_0) ~= this.subsys_n
                error("CompoundHybridSystem:WrongNumberOfInitialStates", ...
                    "Wrong number of initial states. Expected=%d, actual=%d", ...
                    this.subsys_n, length(xs_0))
            end
            for i=1:this.subsys_n
                ss_dim = this.subsystems{i}.state_dimension;
                assert(all(size(xs_0{i}) == [ss_dim, 1]), ...
                    "System %d has state dimension %d but the initial value had shape %s.",...
                    i, ss_dim, mat2str(size(xs_0{i})));
            end
            xs_0 = cat(1, xs_0{:});
            js_0 = jspan(1)*ones(length(this.subsystems), 1);
            
            x0 = [xs_0; js_0];
            
            if ~exist("config", "var")
                config = HybridSolverConfig();
            end
            
            if config.hybrid_priority == HybridPriority.FLOW
                warning("CompoundHybridSystem:FlowPriorityNotSupported", "Using CompoundHybridSystems with FLOW priority is not reccomended. " + ...
                    "When two subsystems are in their respective jump sets and one of them leaves " +...
                    "its flow set, then the state of both will jump, violating flow priority.")
            end
            
            sol = this.solve@HybridSystem(x0, tspan, jspan, config);
        end
    end
    
    methods(Access = protected)
        function sol = wrap_solution(this, t, j, x, tspan, jspan)
            % Create the HybridSolution object for the compound system.
            sol = this.wrap_solution@HybridSystem(t, j, x, tspan, jspan);
            
            total_jump_count = j(end) - j(1);
            
            [xs_all, js_all] = this.split_many(x);
            for i=1:length(this.subsystems)
                ss = this.subsystems{i};
                ss_j = js_all(:, i);
                ss_x = xs_all(:, this.x_indices{i});
                ss_u = NaN(length(t), ss.input_dimension);
                
                % Create arrays is_a_ss1_jump_index and is_a_ss2_jump_index,
                % which contain ones at entry where a jump occured in the
                % corresponding system.
                [~, ~, ~, is_jump] = HybridUtils.jumpTimes(t, ss_j);
                
                % Compute the input values
                for k = 1:length(t)
                    xs = {};
                    for indices = this.x_indices
                        xs{end+1} = x(k, indices{1})';
                    end
                    ys = compute_outputs(this, xs);
                    if is_jump(k)
                        % u(k, :) = this.kappa_D{i}(xs, t, ss_j)';
                        ss_u(k, :) = eval_feedback(this.kappa_D{i}, ys, t, ss_j)';
                    else % is flow
                        % u(k, :) = this.kappa_C{i}(xs, t, ss_j)';
                        ss_u(k, :) = eval_feedback(this.kappa_C{i}, ys, t, ss_j)';
                    end
                end
                
                % In order to find the TerminationCause for the subsystem
                % solutions, we need to adjust jspan for each so that we only count
                % jumps in the appropriate subystem. To this end, we calculate the
                % number of jumps in each subsystem. The results
                % are subtracted from the end of jspan to create jspan1 and
                % jspan2.
                ss_jump_count = ss_j(end) - ss_j(1);
                others_jump_count = total_jump_count - ss_jump_count;
                ss_jspan = [jspan(1), jspan(end) - others_jump_count];
                ss_sols{i} = ss.wrap_solution(t, ss_j, ss_x, ss_u, tspan, ss_jspan); %#ok<AGROW>
            end
            sol = CompoundHybridSolution(sol, ss_sols, tspan, jspan);
        end
    end

    methods(Access = private)
        
        function [xs, js] = split(this, x)
            % SPLIT Split a full state vector into a cell array containing
            % the subsystem state vectors, and a numeric array containing
            % the subsystem discrete time-values. 
            
            % We found that this function had the largest impact on the
            % runtime of computing solutions, so we have taken pains to
            % optimize it. 
            
            % Save the "indexs" to local variables to speed up reading them.
            x_ndxs = this.x_indices;
            j_ndxs = this.j_index;
            N = length(x_ndxs);
            
            % Preallocating xs and js cut down the total time to execute
            % split() by 30%, in one test.
            xs = cell(N, 1);
            js = NaN(N, 1);
            for i = 1:N
                xs{i} = x(x_ndxs{i});
                js(i) = x(j_ndxs(i));
            end
        end
        
        function [xs, js] = split_many(this, x)
            % SPLIT_MANY
            ndxs = cell2mat(this.x_indices);
            x_cols = max(ndxs) - min(ndxs) + 1;
            j_cols = length(this.x_indices);
            rows = size(x, 1);
            xs = NaN(rows, x_cols);
            js = NaN(rows, j_cols);
            for i = 1:this.subsys_n
                xs(:, this.x_indices{i}) = x(:, this.x_indices{i});
                js(:, i) = x(:, this.j_index(i));
            end
        end
        
        function ys = compute_outputs(this, xs)
            ys = cell(this.subsys_n, 1);
            for i = 1:this.subsys_n
                ys{i} = this.subsystems{i}.output(xs{i});
            end
        end

        function ndx = subsys_arg_to_ndx(this, subsys)
            if isa(subsys, "ControlledHybridSystem")
                ndx = this.get_subsystem_index(subsys);
                if isempty(ndx)
                    error("Argument was not a subsystem in this system.")
                end
            elseif isnumeric(subsys) 
                % Don't use isinteger here because Matlab interprets
                % literal numbers in code, such as "2", as doubles.
                ndx = subsys;
            else
                error("Argument must be either a ControlledHybridSystem object or an integer");
            end
        end
        
        function ndx = get_subsystem_index(this, subsystem)
            ndx = find(cellfun(@(x)x == subsystem,this.subsystems));
        end
        
        function check_feedback(this, kappa)
            nargs = nargin(kappa);
            expected_nargs = this.subsys_n + 2;
            if nargs ~= expected_nargs
               error("CompoundHybridSystem:WrongNumberFeedbackInputArgs", ...
                   "Wrong number of input arguments. Expected=%d, actual=%d.",...
                   expected_nargs, nargs) 
            end
        end
    end
end

function subsystems = split_constructor_varagin(varargin_cell)
subsystems = varargin_cell;
for i = 1:length(subsystems)
    assert(isa(subsystems{i}, "ControlledHybridSystem"), ...
        "subsystem{%d} was a %s instead of a ControlledHybridSystem", ...
        i, class(subsystems{i}))
    assert(isscalar(subsystems{i}), "Input arguments must be scalars.")
end
end

function u = eval_feedback(kappa, ys, t, j)
switch length(ys)
    case 1
        u = kappa(ys{1}, t, j);
    case 2
        u = kappa(ys{1}, ys{2}, t, j);
    case 3
        u = kappa(ys{1}, ys{2}, ys{3}, t, j);
    case 4
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, t, j);
    case 5
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, ys{5}, t, j);
    case 6
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, ys{5}, ys{6}, t, j);
    case 7
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, ys{5}, ys{6}, ys{7}, t, j);
    otherwise
        error("The maximum number of subsystems is seven.");
end
end

function kappas = generate_default_feedbacks(subsystems)

sys_count = length(subsystems);
kappas = cell(sys_count, 1);
args_fmt = join(repmat("y%d", sys_count, 1), ", ");
feedback_arugments_string = sprintf(args_fmt, 1:sys_count);
for i = 1:sys_count
    n = subsystems{i}.input_dimension;
    kappa_eval_string = sprintf("kappas{i} = @("+feedback_arugments_string+", t, j) zeros(%d, 1);", n);
    eval(kappa_eval_string);
end

end

function assert_control_length(u_length, subsys_input_dimension, sys_ndx)
if ~(u_length == subsys_input_dimension)
    err_id = 'CompoundHybridSystem:DoesNotMatchInputDimension';
    msg = sprintf("Vector does not match input dimension for system %d. Expected=%d, actual=%d.", ...
        sys_ndx, subsys_input_dimension, u_length);
    throwAsCaller(MException(err_id,msg))
end
end

function assert_state_length(x_length, subsys_state_dimension, sys_ndx)
if ~(x_length == subsys_state_dimension)
    err_id = 'CompoundHybridSystem:DoesNotMatchStateDimension';
    msg = sprintf("Vector does not match state dimension for system %d. Expected=%d, actual=%d.", ...
        sys_ndx, subsys_state_dimension, x_length);
    throwAsCaller(MException(err_id,msg))    
end
end