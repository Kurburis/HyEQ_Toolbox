classdef CompoundHybridSystem < HybridSystem
%%% COMPOUNDHYBRIDSYSTEM Creates a hybrid system that consists of N
%%% subsystems. The subsystems are provided as instances of
%%% ControlledHybridSystem with inputs generated by feedback functions
%%% stored in kappa_C and kappa_D. The kappa_C feedbacks are used during
%%% flows and the kappa_D feedbacks are used at jumps.
%%%
%%% The state for the compound system consists of 
%%%     [x1; x2; ...; xN; j1; j2; ...; jN] 
%%% where x1 is the state vector for the first subsystem, x2 is the state
%%% vector for the second subsystem, etc., and j1 is the discrete time for
%%% the first subsystem, j2 is the discrete time for the second subsystem,
%%% and so on. (The subsystems jump separately of each other, so we
%%% maintain separate discrete times).

    properties
        % Feedback function for each subsystem during flows. 
        % Each entry must be set to a function handle with a signiture matching 
        %    u = kappa_C(x1, x2, ..., xN, t, j)
        % where N is the number of subsystems.
        kappa_C (:, 1) cell;
        
        % Feedback functions for each subsystem at jumps. 
        % Each entry must be set to a function handle with a signiture matching 
        %    u = kappa_D(x1, x2, ..., xN, t, j)
        % where N is the number of subsystems.
        kappa_D (:, 1) cell;
    end
    
    properties(GetAccess = private, SetAccess = immutable)
        subsystems (:, 1) cell = {}; 
        subsys_n;
    end
    
    properties(GetAccess = private, SetAccess = immutable) 
        % The following properties are private because they might change in
        % future implementaitons. 
        
        % Indicies within the compound state of subsystem1's state 
        x_indices cell
        % Index within the compound state of subsystem1's discrete time.
        j_index (:, 1) int32 
    end
    
    methods
        function obj = CompoundHybridSystem(subsystems) % Constructor
           obj = obj@HybridSystem();
           obj.subsystems = subsystems;
           subsys_n = length(subsystems);
           obj.subsys_n = subsys_n;
           ndx = 1; % Start index for ith subsystem state variable.
           for i = 1:subsys_n
               ss = subsystems{i} ;
               ss_n = ss.state_dimension;
               obj.x_indices{i} = ndx : (ndx + ss_n - 1);
               ndx = ndx + ss_n;
           end
           for i = 1:subsys_n
              obj.j_index(i) = ndx;
              ndx = ndx + 1;
           end
           obj.state_dimension = ndx-1;
           
           obj.kappa_C = generate_default_feedbacks(subsystems);
           obj.kappa_D = generate_default_feedbacks(subsystems);
        end
    end
    
    methods(Sealed)
        
        function xdot = flow_map(this, x, t) 
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs, t, js);
            % We set xdot to zeros and then fill in the entries
            % corresponding to the state of each subsystem and leave zero
            % the entries corresponding to the j-values.  
            xdot = zeros(this.state_dimension, 1); 
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               
               u = eval_feedback(this.kappa_C{i}, ys, t, js);
               assert_control_length(length(u), ss.control_dimension, i)
               xdot(this.x_indices{i}) = ss.flow_map(xs{i}, u, t, j);
            end
        end 

        function xplus = jump_map(this, x, t)  
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs, t, js);
            xplus = NaN(this.state_dimension, 1);
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               u = eval_feedback(this.kappa_D{i}, ys, t, js);
               assert_control_length(length(u), ss.control_dimension, i)
               D = ss.jump_set_indicator(xs{i}, u, t, j);
               if ~isscalar(D)
                   error("CompoundHybridSystem:InvalidFunction", ...
                       "The jump set indicator function for system %d returned an array.", i)
               end
               if D
                   xplus_i = ss.jump_map(xs{i}, u, t, j);
                   jplus_i = j + 1;
               else
                   xplus_i = xs{i};
                   jplus_i = j;
               end
               xplus(this.x_indices{i}) = xplus_i;
               xplus(this.j_index(i)) = jplus_i;
            end
        end

        function C = flow_set_indicator(this, x, t) 
            % The system can only flow if both subsystems are in their
            % repsective flow sets (priority is honored, if the compound
            % state is in (C union D)).
            C = true; 
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs, t, js);
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               u = eval_feedback(this.kappa_C{i}, ys, t, js);
               assert_control_length(length(u), ss.control_dimension, i)
               C = ss.flow_set_indicator(xs{i}, u, t, j);
               if ~isscalar(C)
                   error("CompoundHybridSystem:InvalidFunction", ...
                       "The flow set indicator function for system %d returned an array.", i)
               end
               if ~C
                   % If any of the subsystems are not in their flow set,
                   % then the compound system does not flow.
                   break;
               end
            end
        end

        function D = jump_set_indicator(this, x, t)
            D = false; 
            [xs, js] = this.split(x);
            ys = this.compute_outputs(xs, t, js);
            for i=1:length(this.subsystems)
               ss = this.subsystems{i};
               j = js(i);
               u = eval_feedback(this.kappa_D{i}, ys, t, js);
               assert_control_length(length(u), ss.control_dimension, i)
               D = ss.jump_set_indicator(xs{i}, u, t, j);
               if D
                   % If any of the subsystems are in their jump set,
                   % then the compound system jumps.
                   break;
               end
            end
        end
    end

    methods
        
        function sol = solve(this, xs_0, tspan, jspan, config)
            % SOLVE Compute the solution to the compound system with the
            % initial state of subsystem1 given by x1_0 and the initial
            % state of subsystem2 given by x2_0. See HybridSystem.solve() for
            % explanation of tspan, jspan, and config.
            
            % We concatenate the subsystem states and inital j-value to create 
            % the compound state. (The subsystems can jump at separate times, 
            % so track the jumps for each in the last components of the 
            % compound state).
            assert(iscell(xs_0), "xs_0 must be a cell array")
            assert(length(xs_0) == this.subsys_n, "Wrong number of initial states")
            for i=1:this.subsys_n
                ss_dim = this.subsystems{i}.state_dimension;
                assert(all(size(xs_0{i}) == [ss_dim, 1]), ...
                    "System %d has state dimension %d but the initial value had shape %s.",...
                    i, ss_dim, mat2str(size(xs_0{i})));
            end
            xs_0 = cat(1, xs_0{:});
            js_0 = jspan(1)*ones(length(this.subsystems), 1);
            
            x0 = [xs_0; js_0];
            
            if ~exist("config", "var")
                config = HybridSolverConfig();
            end
            
            sol = this.solve@HybridSystem(x0, tspan, jspan, config);
        end
    end
    
    methods(Access = protected)
        function sol = wrap_solution(this, t, j, x, tspan, jspan)
            % Create the HybridSolution object for the compound system.
            sol = this.wrap_solution@HybridSystem(t, j, x, tspan, jspan);
            
            total_jump_count = j(end) - j(1);
            
            [xs_all, js_all] = this.split_many(x);
            for i=1:length(this.subsystems)
                ss = this.subsystems{i};
                ss_j = js_all(:, i);
                ss_x = xs_all(:, this.x_indices{i});
                ss_u = NaN(length(t), ss.control_dimension);
                
                % Create arrays is_a_ss1_jump_index and is_a_ss2_jump_index,
                % which contain ones at entry where a jump occured in the
                % corresponding system.
                [~, ~, ~, is_jump] = HybridUtils.jumpTimes(t, ss_j);
                
                % Compute the input values
                for k = 1:length(t)
                    xs = {};
                    for indices = this.x_indices
                        xs{end+1} = x(k, indices{1})';
                    end
                    ys = compute_outputs(this, xs, t, ss_j);
                    if is_jump(k)
                        % u(k, :) = this.kappa_D{i}(xs, t, ss_j)';
                        ss_u(k, :) = eval_feedback(this.kappa_D{i}, ys, t, ss_j)';
                    else % is flow
                        % u(k, :) = this.kappa_C{i}(xs, t, ss_j)';
                        ss_u(k, :) = eval_feedback(this.kappa_C{i}, ys, t, ss_j)';
                    end
                end
                
                % In order to find the TerminationCause for the subsystem
                % solutions, we need to adjust jspan for each so that we only count
                % jumps in the appropriate subystem. To this end, we calculate the
                % number of jumps in each subsystem. The results
                % are subtracted from the end of jspan to create jspan1 and
                % jspan2.
                ss_jump_count = ss_j(end) - ss_j(1);
                others_jump_count = total_jump_count - ss_jump_count;
                ss_jspan = [jspan(1), jspan(end) - others_jump_count];
                ss_sols{i} = ss.wrap_solution(t, ss_j, ss_x, ss_u, tspan, ss_jspan); %#ok<AGROW>
            end
            sol = CompoundHybridSolution(sol, ss_sols, tspan, jspan);
        end
    end

    methods(Access = private)
        
        function [xs, js] = split(this, x)
            % SPLIT Split a full state vector into a cell array containing
            % the subsystem state vectors, and a numeric array containing
            % the subsystem discrete time-values. 
            
            % We found that this function had the largest impact on the
            % runtime of computing solutions, so we have taken pains to
            % optimize it. 
            
            % Save the "indexs" to local variables to speed up reading them.
            x_ndxs = this.x_indices;
            j_ndxs = this.j_index;
            N = length(x_ndxs);
            
            % Preallocating xs and js cut down the total time to execute
            % split() by 30%, in one test.
            xs = cell(N, 1);
            js = NaN(N, 1);
            for i = 1:N
                xs{i} = x(x_ndxs{i});
                js(i) = x(j_ndxs(i));
            end
        end
        
        function [xs, js] = split_many(this, x)
            % SPLIT_MANY
            ndxs = cell2mat(this.x_indices);
            x_cols = max(ndxs) - min(ndxs) + 1;
            j_cols = length(this.x_indices);
            rows = size(x, 1);
            xs = NaN(rows, x_cols);
            js = NaN(rows, j_cols);
            for i = 1:this.subsys_n
                xs(:, this.x_indices{i}) = x(:, this.x_indices{i});
                js(:, i) = x(:, this.j_index(i));
            end
        end
        
        function ys = compute_outputs(this, xs, t, js)
            ys = cell(this.subsys_n, 1);
            for i = 1:this.subsys_n
                ys{i} = this.subsystems{i}.output(xs{i}, t, js(i));
            end
        end
    end
end

function u = eval_feedback(kappa, ys, t, j)
switch length(ys)
    case 1
        u = kappa(ys{1}, t, j);
    case 2
        u = kappa(ys{1}, ys{2}, t, j);
    case 3
        u = kappa(ys{1}, ys{2}, ys{3}, t, j);
    case 4
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, t, j);
    case 5
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, ys{5}, t, j);
    case 6
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, ys{5}, ys{6}, t, j);
    case 7
        u = kappa(ys{1}, ys{2}, ys{3}, ys{4}, ys{5}, ys{6}, ys{7}, t, j);
    otherwise
        error("The maximum number of subsystems is seven.");
end
end

function kappas = generate_default_feedbacks(subsystems)

sys_count = length(subsystems);
kappas = cell(sys_count, 1);
args_fmt = join(repmat("x%d", sys_count, 1), ", ");
feedback_arugments_string = sprintf(args_fmt, 1:sys_count);
for i = 1:sys_count
    n = subsystems{i}.control_dimension;
    kappa_eval_string = sprintf("kappas{i} = @("+feedback_arugments_string+", t, j) zeros(%d, 1);", n);
    eval(kappa_eval_string);
end

end

function assert_control_length(u_length, subsys_control_dimension, sys_ndx)
assert(u_length == subsys_control_dimension, ...
   "Input is wrong size for system %d. Expected=%d, actual=%d.", ...
   sys_ndx, subsys_control_dimension, u_length)

end