%% Creating plots with HybridPlotBuilder
%% Setup
% The |HybridPlotBuilder| class provides an easy and configurable way to plot 
% hybrid solutions. We first create several solutions that are used in
% subsequent examples.
system = ExampleBouncingBallHybridSystem();
system_3D = Example3DHybridSystem();
config = HybridSolverConfig("Refine", 15); % "Refine" option makes the plots smoother.
sol = system.solve([10, 0], [0 30], [0 30], config);
sol_3D = system_3D.solve([0; 1; 0], [0, 20], [0, 100], config);

%% Basic Plotting
% To create a plot of a hybrid solution |sol|, we create an instance of
% |HybridPlotBuilder| by calling the constructor |HybridPlotBuilder()| and
% assigning the object to the variable |pb|. Plots are generated by the
% function calls |pb.plotFlows(sol)|, |pb.plotJumps(sol)|,
% |pb.plotHybrid(sol)|, or simply |pb.plot(sol)|. For |plotFlows|,
% |plotJumps|, |plotHybrid|, 
% each component (up to four by default) of |sol.x| is placed in a separate
% subplot. If the plot builder is only used once, it is unnecessary to
% assign it to a variable and can instead be used immediately, e.g.,
% |HybridPlotBuilder().plotFlows(sol)|.
% 
% The |plotFlows| function plots each component of the solution versus
% continuous time $t$. 
HybridPlotBuilder().plotFlows(sol);

%% 
% The |plotJumps| function plots each component of the solution versus
% discrete time $j$.
HybridPlotBuilder().plotJumps(sol);

%% 
% The |plotHybrid| function plots each component of the solution versus
% hybrid time $(t, j)$.
HybridPlotBuilder().plotHybrid(sol);

%%
% The |plot| function chooses the type of plot based on the number of
% components. For solutions with two or three components, then |plot|
% produces a plot in 2D or 3D state space. Otherwise, each component is
% plotted using |plotFlows|.
HybridPlotBuilder().plot(sol);

%% 
% Each of the four preceeding function calls can be abbreviated by omitting
% |HybridPlotBuilder()|, that is |plotFlows(sol)|, |plotJumps(sol)|,
% |plotHybrid(sol)|, and 
% |plot(sol)|. 
plot(sol)

%%
% This approach, although convenient, does not allow the modifications of the plot
% appearances that we describe below. 

%% Choosing Components to Plot
% For solutions with multiple components, the |slice| function allows for the
% selection of which components to plot and which order to plot them.
% We will look at the following solution to a 3D system.
plot(sol_3D)
view([63.6 28.2]) % Set the view angle.

%%
% We plot only the first two components by passing the array.
% [1, 2] to |slice|.
HybridPlotBuilder().slice([1,2]).plot(sol_3D);

%% 
% The |slice| function also allows the order of components to be changed.
HybridPlotBuilder().slice([2,1]).plot(sol_3D);

%% Ploting Other Values
% To plot a series of values other than the state, pass t, j, and the
% desired values to the plotting function of choice.
HybridPlotBuilder().slice(1).plotFlows(sol.t, sol.j, -sol.x)
title("Negative Height")

%% 
% Rather then referencing sol.t and sol.j, the solution object can be
% passed to the plotting function, along with the plot values. The time
% values from |sol| are then used.
HybridPlotBuilder().slice(1).plotFlows(sol, -sol.x)
title("Negative Height")

%% 
% Alternatively, a function can be evaluated along the solution and plotted
% as follows. The evaluation of the funciton is done via the function
% |HybridSolution.evaluateFunction()|.
HybridPlotBuilder().plotFlows(sol, @(x) -x(1)); % Can also use @(x, t) or @(x, t, j).

%% Customizing Plot Appearance
% The following functions modify the appearance of flows.
HybridPlotBuilder().slice(1)...
    .flowColor("black")...
    .flowLineWidth(2)...
    .flowLineStyle(":")...
    .plotFlows(sol)

%% 
% Similarly, we can change the appearance of jumps.
HybridPlotBuilder().slice(1:2)...
    .jumpColor("m")...
    .jumpLineWidth(1)...
    .jumpLineStyle("-.")...
    .jumpStartMarker("+")...
    .jumpStartMarkerSize(16)...
    .jumpEndMarker("o")...
    .jumpEndMarkerSize(10)...
    .plot(sol_3D)

%% 
% To confiugre the the jump markers on both sides of jumps, omit "Start"
% and "End" from the function names:
HybridPlotBuilder().slice(1:2)...
    .jumpMarker("s")... % square
    .jumpMarkerSize(12)...
    .plot(sol_3D)

%% 
% To hide jumps or flows, set the corresponding color to "none." Jump
% markers can be hidden by setting the marker style to "none" and jump
% lines can be hidden by setting the jump line style to "none."
HybridPlotBuilder().slice(2)...
    .flowColor("none")...
    .jumpEndMarker("none")...
    .jumpLineStyle("none")...
    .plotFlows(sol)
title("Start of Each Jump") % An alternative way to add titles is shown below.

%% Component Labels
% Plot labels are set component-wise. In the bouncing ball system, the first
% component is height and the second is velocity, so we will add the labels
% $h$ and $v$. |HybridPlotBuilder| automatically adds labels for $t$ and $j$.
HybridPlotBuilder()...
    .labels("$h$", "$v$")...
    .plotFlows(sol)

%% 
% If |slice| is used to switch the order of components, then the labels
% automatically switch also.
HybridPlotBuilder().slice([2 1])...
    .labels("$h$", "$v$")...
    .plotFlows(sol)

%% 
% Labels are also displayed for plots in phase space.
HybridPlotBuilder().slice([2 1])...
    .labels("$h$", "$v$")...
    .plot(sol)

%%
% The |t| and |j| axis labels and the default label for the state
% components can be modified as follows. If the string passed to
% |xLabelFormat| contains |"%d"|, then it is substituted with the index
% number of the component.
HybridPlotBuilder()...
    .tLabel("$t$ [s]")...
    .jLabel("$j$ [k]")...
    .xLabelFormat("$z_{%d}$")...
    .plotHybrid(sol)

%% Plot Titles
% Adding titles is similar to adding labels.
clf
HybridPlotBuilder().slice([2 1])...
    .titles("Height", "Velocity")...
    .plotFlows(sol)

%% 
% One place where the behavior of labels and titles differ are in 2D or 3D
% plots of a solution in phase space. 
% A plot in phase space only contains one subplot, so only the first title
% is displayed. For this case, the |title| function can be used instead of
% |titles|.
HybridPlotBuilder().title("Phase Plot").plot(sol)

%% 
% The default interpreter for text is |latex| and can be changed by calling
% |titleInterpreter()| or |labelInterpreter()|. Use one of these values:
% |none| | |tex| | |latex|. The default labels automatically adjust there
% formatting to match the label interpreter.
HybridPlotBuilder()...
    .titleInterpreter("none")...
    .labelInterpreter("tex")...
    .title("My title x_1 $x_1$") ...
    .labels("z_1", "$z_2$")... % Unlike 'latex', do not put dollar signs around math.
    .plotFlows(sol_3D)

%% Automatic Subplots
% By default, |HybridPlotBuilder| creates a new subplot for each component
% of the solution for |plotFlows|, |plotJumps|, and |plotHybrid|. 
HybridPlotBuilder().plotFlows(sol)

%% 
% This can be disabled via tha |autoSubplots| function. If automatic
% subplots are turned off, then all components are plotted in a single axes. 
clf
HybridPlotBuilder()...
    .autoSubplots("off")...
    .plotFlows(sol) 

%%
% When automatic subplots are off, only the first label and title are used.
% For legends, however, as many legend entries are used as plots have been
% added. 
pb = HybridPlotBuilder();
pb.autoSubplots("off")...
    .labels("Label 1", "Label 2")... % Only first label is used.
    .titles("Title 1", "Title 2")... % Only first title is used.
    .plotFlows(sol)
pb.legend("Legend 1", "Legend 2") % Both two legend entries are used.

%% Filtering Solutions
% Portions of solutions can be hidden with the |filter| function. In this
% example, we create a filter that only includes points where the second
% component (velocity) is negative. (If the time-step size
% along flows is large, hidden lines connected to filtered points may
% extends a noticible distance into the portion of the solution that should
% be visible.)
clf
is_falling = sol.x(:,2) < 0;
HybridPlotBuilder()...
    .filter(is_falling)...
    .plotFlows(sol)

%% Plotting System Modes
% Filtering is useful for plotting systems where an integer-value
% component indicates the mode of the system. 
% Here, we create a 3D system with a continuous variable $z \in \bf{R}^2$
% and a discrete variable $q \in \{0, 1\}$. Points in the solution where 
% $q = 0$ are plotted in blue, and points where $q = 1$ are plotted in
% black. The same |HybridPlotBuilder| object is used for both plots by saving it 
% to the |builder| variable (this allows us to specify the labels only
% once and add a legend for both plots). 
system_with_modes = ExampleModesHybridSystem();

% Create initial condition and solve.
z0 = [-7; 7];
q0 = 0;
sol_modes = system_with_modes.solve([z0; q0], [0, 10], [0, 10], "silent");

% Extract values for q-component.
q = sol_modes.x(:, 3);

% Plot the [1, 2] components (that is, the first two components) of
% sol_modes at all time steps where q == 0. 
builder = HybridPlotBuilder();
builder.title("Phase Portrait") ...
    .labels("$x_1$", "$x_2$") ...
    .slice([1,2]) ... % Pick which state components to plot
    .filter(q == 0) ... % Only plot points where q is 0.
    .plot(sol_modes)
hold on % See the section below about "hold on"
% Plot in black the solution (still only the [1,2] components) for all time
% steps where q == 1. 
builder.flowColor("black") ...
    .jumpColor("none") ...
    .filter(q == 1) ... % Only plot points where q is 1.
    .plot(sol_modes)
axis padded
axis equal

%% Legends
% Next, we add a legend to the previous plot. 
% The |plot| function is called on a single instance of
% |HybridPlotBuilder|, so the legend will have two entries. 
builder.legend("$q = 0$", "$q = 1$");

%% 
% When using auto-subplots, legends are added to each subplot.
clf
pb = HybridPlotBuilder();
pb.plotFlows(sol);
hold on
pb.flowColor("k").jumpColor("g").slice(1:2).plotFlows(sol_3D);
pb.legend("Plot 1", "Plot 2");

%% 
% A single |HybridPlotBuilder| object can be used to add plots and legends to
% multiple figures.
clf
pb = HybridPlotBuilder();
pb.plotFlows(sol_3D); % Ignored in second figure
pb.legend("First Figure"); 
%%
clf
pb.flowColor("k").jumpColor("g").plotFlows(sol); % Still using "pb"
pb.legend("Second Figure"); % Ignores plot in first figure

%%
% Plots added to a figure without |HybridPlotBuilder| can be added to
% tbe legend by passing the output argument of |plot| to |addLegendEntry|.
clf
pb = HybridPlotBuilder();
pb.plot(sol)
hold on
axis equal
% Plot a circle.
theta = linspace(0, 2*pi);
plt = plot(10*cos(theta), 10*sin(theta), "m");
% Pass the circle to the plot builder.
pb.addLegendEntry(plt);

pb.legend("Hybrid Plot", "A circle")

%% 
% Cleared and closed figures are handled gracefully by |legend|.
clf
pb = HybridPlotBuilder();
pb.plotFlows(sol_3D);
clf
pb.flowColor("k").plotFlows(sol); 
pb.legend("Plot 1"); % Only one legend because there is only one plot.
close 
pb.legend("Only second plot"); % Nothing done.

%% Replacing vs. Adding Plots to a Figure
% By default, each call to a HybridPlotBuilder plot function overwrites the 
% previous plots. In the following code, we call |plotFlows| twice. The
% first call plots a solution in blue and red, but the second call resets the figure
% and plots a solution in black and green.
tspan = [0 10];
jspan = [0 30];
sol1 = system.solve([10, 0], tspan, jspan, config);
sol2 = system.solve([ 5, 10], tspan, jspan, config);

clf
HybridPlotBuilder()... % Plots blue flows and red jumps by default.
    .plotFlows(sol1)
HybridPlotBuilder().flowColor('black').jumpColor("green")...
    .title("Multiple Calls to $\texttt{plotFlows}$ with \texttt{hold off}") ...
    .plotFlows(sol2)
%% 
% To plot multiple graphs on the same figure, use |hold on|, similar to
% standard MATLAB plotting functions.
HybridPlotBuilder().plotFlows(sol1) % Plots blue flows and red jumps by default.
hold on
HybridPlotBuilder().flowColor('black').jumpColor("green")...
    .title("Multiple Calls to $\texttt{plotFlows}$ with \texttt{hold on}")...
    .plotFlows(sol2)
hold off

%% Modifying Defaults
% 
clf
HybridPlotBuilder.setDefault("Label Size", 18)
HybridPlotBuilder.setDefault("Title Size", 12)
HybridPlotBuilder.setDefault("Label interpreter", 'tex')
HybridPlotBuilder.setDefault("Title interpreter", 'none')
HybridPlotBuilder.setDefault("flow line width", 5)
HybridPlotBuilder.setDefault("jump line width", 3)

HybridPlotBuilder()...
    .title("Title")...
    .plotFlows(sol);

%% 
% The defaults can be reset to their original values by calling
% |resetDefaults| on |HybridPlotBuilder|.
clf
HybridPlotBuilder.resetDefaults()

HybridPlotBuilder()...
    .title("Title")...
    .plotFlows(sol);

%% Additional configuration
% There are numerous options for configuring the appearance of Matlab plots
% that are not included explicitly in HybridPlotBuilder (see
% <https://www.mathworks.com/help/matlab/ref/matlab.graphics.axis.axes-properties.html
% here>).
% For plots with a single subplot, the appearance can be modified using the
% same methods as for any other Matlab plot. 

HybridPlotBuilder().plot(sol);
grid on
ax = gca;
ax.YAxisLocation = "right";

%%
% Plots with multiple subplots can also be configured as described above by
% calling |subplot(2, 1, 1)| and making the desired modifications, then
% calling |subplot(2, 1, 2)|, etc., but that approach 
% is messy and repetative. Instead, the |configureSubplot| function provides a
% cleaner alternative. A function handle is passed to |configureSubplot|,
% which is then called by |HybridPlotBuilder| when each subplot is active.
% The function handle passed to |configureSubplot| must take one input
% argument, which is set to the index of the state component for the active
% subplot. 
HybridPlotBuilder()...
    .configureSubplots(@apply_plot_settings)...
    .plotFlows(sol);

function apply_plot_settings(component)
    title(sprintf("This is the plot of component %d", component))
    subtitle('An Insightful Subtitle','FontAngle','italic')
    ax = gca;
    ax.GridLineStyle = '--';
    ax.LabelFontSizeMultiplier = 1.8;
    grid on
    grid minor
end